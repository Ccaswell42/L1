1) strings.Builder. Использует метод write, что сводит к минимуму копирование памяти
2) Интерфейсы - абстрактный тип данных, выражает абстракции поведения других типов.
В интерфейсе описаны методы, которые должны быть реализованы для других структур, которые будут удовлетворять этому интерфейсу. 
Удовлетворение интерфейсу поддерживается на неявном уровне. То есть для объекта достаточно описать реализацию методов интерфейса. 
И объект, без дополнительных объявлений в кодовой базе, начинает удовлетворять этому интерфейсу.
Интерфейсы позволяют писать более гибкие и адаптируемые функции, непревязанные к деталям одной конкретной реализации.
3) RXMutex в отличии от обычного Mutex имеет  дополнительные методы (RLock/RUnlock) которые не блокируют чтение в других горутинах, 
только заппись. Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.
4) Буферезированный канал:
чтение не блокирующие - пока буфер не пуст, далее идет блокировка.
Запись не блокирующая - пока не заполнится буфер канала.

Небуферизированный канал - это тот же буферизированный канал, но с nil буфером. Соответственно принцип его работы будет таким же. 
Чтение из пустого и запись в непустой небуферизированный канал являются блокирующими операциями.

5) 0 байт
6) перегрузки нет.
Перегрузка методов - возможно создания методов с одинаковым названием, но разной сигнатурой.(например, разное кол-во параметров)
Перегрузка оператора — это когда мы обучаем язык программирования, как оператору типа плюс, минус, умножить и т. д. 
вести себя с определённым типом вводных — например, с объектами, матрицами или картинками.

7) В рандомной

8) New - принимает тип, аллоцирует память и возвращает указатель на созданную переменную.
Make - выделят и инициализирует объект только типа map, slice, chan. Возвращает объект того же типа, а не указатель.
9)  Три
d := []byte{'r', 'o', 'a', 'd'} 
    d := map[int]string{
		10 : "apple",
	}
    a := make([]byte)
    a := make(map[int]string)

    var b map[string]int //< - объявили, но не инициализировали, при добавлени будет panic: assignment to entry in nil map
    var b []byte

10) Выведется 1, 1 потому что внутри работает с копией укзателя а не со значением переменной. для изменения нужно: *p=b
11) Выведутся числа от 0 до 4 включительно в хаотичном порядке, далее дедлок. Нужно передать WaitGroup по указателю для решения проблемы.
12) Выведется 0, поскольку фигурными скобками мы задаем ограничееную область видимости, и переменные за ее пределами не доступны.
13) До того как мы сделали append, мы имели дело со слайсом, который ссылался на слай 'a' как на базовый. А во время аппенда память
переаллоцировалась и теперь внутри функции someAction слайс v ссылается сам на себя, как на базовый, поэтому первое значение в слайсе "a"
поменялось, но новый элемент к нему не прибавился.
14)По аналогии с предыдущей задаче при аппенде память переалоцировалась, и теперь внутри анонимной фукнции "slice" 
ссылается уже на другой слайс(сам на себя), в качестве базового и не меняет значения оригинального, переданного ему в аргументе.